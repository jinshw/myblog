---
title: 网络（协议一）
date: 2018-05-09 14:27:47
tags: [网络,协议]
---
# TCP/IP 协议

![upload successful](/images/http/tcp-ip2.png)

<!-- more -->

- **链路层**：对0和1进行分组，定义数据帧，确认主机的物理地址，传输数据；
- **网络层**：定义IP地址，确认主机所在的网络位置，并通过IP进行MAC寻址，对外网数据包进行路由转发；
- **传输层**：定义端口，确认主机上应用程序的身份，并将数据包交给对应的应用程序；
- **应用层**：定义数据格式，并按照对应的格式解读数据。


  	当你输入一个网址并按下回车键的时候，首先，应用层协议对该请求包做了格式定义；紧接着传输层协议加上了双方的端口号，确认了双方通信的应用程序；然后网络协议加上了双方的IP地址，确认了双方的网络位置；最后链路层协议加上了双方的MAC地址，确认了双方的物理位置，同时将数据进行分组，形成数据帧，采用广播方式，通过传输介质发送给对方主机。而对于不同网段，该数据包首先会转发给网关路由器，经过多次转发后，最终被发送到目标主机。目标机接收到数据包后，采用对应的协议，对帧数据进行组装，然后再通过一层一层的协议进行解析，最终被应用层的协议解析并交给服务器处理。



网上学习资料：

- 《深入浅出 TCP/IP 协议》

  (https://www.cnblogs.com/onepixel/p/7092302.html)



# TCP协议中的三次握手和四次挥手

* TCP协议三次握手连接，如图：

  ![upload successful](/images/http/tcpws.png)

  首先Client端发送连接请求报文，Server段接受连接后回复ACK报文(Acknowledgement:即是确认字符)，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。

* ![upload successful](/images/http/tcpfs.png)
  假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！

  **网上学习资料**：

  《TCP协议中的三次握手和四次挥手》

  (https://blog.csdn.net/whuslei/article/details/6667471/)




* 备注：
在TCP报文的报头中，有几个标志字段：
1、 SYN：同步连接序号，TCP SYN报文就是把这个标志设置为1，来请求建立连接；
2、 ACK：请求/应答状态。0为请求，1为应答；
3、 FIN：结束连线。如果FIN为0是结束连线请求，FIN为1表示结束连线；
4、 RST：连线复位，首先断开连接，然后重建；
5、 PSH：通知协议栈尽快把TCP数据提交给上层程序处理。
